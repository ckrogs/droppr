% Generated by roxygen2 (4.1.0): do not edit by hand
% Please edit documentation in R/droppr_main.R
\name{droppr_main}
\alias{droppr_main}
\title{Assess sensitivity to dropped cases}
\usage{
droppr_main(d, analysis, method, n.drops = NULL, unit.vars = NULL,
  eps = NULL, min.pts = NULL, ..., time.warn = TRUE, verbose = TRUE)
}
\arguments{
\item{d}{a data frame}

\item{analysis}{a function, see details}

\item{method}{one of "jackknife" or "dbscan"}

\item{n.drops}{number of units to drop in each iteration (jackknife only)}

\item{unit.vars}{character containing names of variables used to identify unique units (jackknife only)}

\item{eps}{a vector of reachability distances (dbscan only)}

\item{min.pts}{a vector of minimum points values (dbscan only)}

\item{...}{optional arguments passed to \code{fpc::dbscan()}}

\item{time.warn}{logical; whether to give runtime estimate before full execution}

\item{verbose}{logical; whether to print execution information}
}
\value{
Returns a named list with the following components:

\item{\code{base.result}}{result of analysis function on full data}
\item{\code{drop.order}}{vector of dropped units; index corresponds to drop.results}
\item{\code{drop.results}}{a list of dropped results; index corresponds to drop.order }
\item{\code{drop.results.classes}}{a character vector containing result classes}
\item{\code{drop.method}}{the dropping method used}
\item{\code{data}}{a copy of the original dataset; used in \code{droppr_analyze()}}
\item{\code{clusters}}{a vector of method-specific cluster/drop groups}
}
\description{
Implements several dropping methods for assessing result sensitivity,
including nth-order jackknife and DBSCAN
}
\details{
The \code{analysis} argument must be a function taking only one argument named after
the object representing the initial data used in the subsequent analysis.  The body of the
function contains the analytic procedure to be applied to each dataset after case dropping.
See the examples for more.
}
\examples{
# Suppose we have the following analysis:

# reg<-lm(logpgp95~avexpr+logem4, data = ajr)
# summary(reg)$coefficients

# Then the \\code{analysis} argument should take a function as follows:

# myfunc<-function(ajr){
#    reg<-lm(logpgp95~avexpr+logem4, data = ajr)
#    summary(reg)$coefficients
# }
}

